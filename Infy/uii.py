# -*- coding: utf-8 -*-
"""ui.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1GAsNhy3JcjVtQqZLr7y92w94_VzMma7q
"""



import streamlit as st
import cv2
import math
import os
from tempfile import NamedTemporaryFile

def process_video(video_path, output_dir="output"):
    cap = cv2.VideoCapture(video_path)

    if not cap.isOpened():
        return "Error: Couldn't open video file."

    frame_width = int(cap.get(cv2.CAP_PROP_FRAME_WIDTH))
    frame_height = int(cap.get(cv2.CAP_PROP_FRAME_HEIGHT))
    fps = int(cap.get(cv2.CAP_PROP_FPS))

    if not os.path.exists(output_dir):
        os.makedirs(output_dir)

    output_path = os.path.join(output_dir, "processed_video.avi")
    output_video = cv2.VideoWriter(output_path, cv2.VideoWriter_fourcc(*"XVID"), fps, (frame_width, frame_height))

    if not output_video.isOpened():
        return "Error: Couldn't open the video writer."

    fgbg = cv2.createBackgroundSubtractorMOG2()
    min_car_area = 500
    max_car_area = 5000
    tracking_objects = {}
    track_id = 0

    while True:
        ret, frame = cap.read()
        if not ret:
            break

        fg_mask = fgbg.apply(frame)
        contours, _ = cv2.findContours(fg_mask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
        center_points_cur_frame = []

        for contour in contours:
            if cv2.contourArea(contour) < min_car_area or cv2.contourArea(contour) > max_car_area:
                continue

            x, y, w, h = cv2.boundingRect(contour)
            cx = int((x + x + w) / 2)
            cy = int((y + y + h) / 2)
            center_points_cur_frame.append((cx, cy))
            cv2.rectangle(frame, (x, y), (x + w, y + h), (0, 255, 0), 2)

        for pt in center_points_cur_frame:
            same_object_detected = False
            for object_id, prev_pt in tracking_objects.items():
                distance = math.hypot(prev_pt[0] - pt[0], prev_pt[1] - pt[1])
                if distance < 50:
                    tracking_objects[object_id] = pt
                    same_object_detected = True
                    break

            if not same_object_detected:
                tracking_objects[track_id] = pt
                track_id += 1

        for object_id, pt in tracking_objects.items():
            cv2.circle(frame, pt, 5, (0, 0, 255), -1)
            cv2.putText(frame, str(object_id), (pt[0] - 10, pt[1] - 10), cv2.FONT_HERSHEY_SIMPLEX, 0.6, (255, 255, 255), 2, cv2.LINE_AA)

        output_video.write(frame)

    cap.release()
    output_video.release()

    return output_path

def process_photo(photo_path, output_dir="output"):
    if not os.path.exists(output_dir):
        os.makedirs(output_dir)

    photo = cv2.imread(photo_path)
    if photo is None:
        return "Error: Couldn't open photo file."

    gray = cv2.cvtColor(photo, cv2.COLOR_BGR2GRAY)
    edges = cv2.Canny(gray, 50, 150)

    output_path = os.path.join(output_dir, "processed_photo.jpg")
    cv2.imwrite(output_path, edges)

    return output_path

# Streamlit UI
st.title("Media Processing Application")
st.write("Upload a video or photo to process.")

# Video processing
st.subheader("Video Processing")
uploaded_video = st.file_uploader("Upload Video", type=["mp4", "avi", "mov"], key="video_uploader")
if uploaded_video is not None:
    temp_video = NamedTemporaryFile(delete=False)
    temp_video.write(uploaded_video.read())

    st.write("Processing video...")
    processed_video_path = process_video(temp_video.name)

    if os.path.exists(processed_video_path):
        st.write("Processing complete! Download your video below:")
        with open(processed_video_path, "rb") as file:
            st.download_button("Download Processed Video", file, "processed_video.avi")
    else:
        st.write("An error occurred while processing the video.")

# Photo processing
st.subheader("Photo Processing")
uploaded_photo = st.file_uploader("Upload Photo", type=["jpg", "jpeg", "png"], key="photo_uploader")
if uploaded_photo is not None:
    temp_photo = NamedTemporaryFile(delete=False, suffix=".jpg")
    temp_photo.write(uploaded_photo.read())

    st.write("Processing photo...")
    processed_photo_path = process_photo(temp_photo.name)

    if os.path.exists(processed_photo_path):
        st.write("Processing complete! Download your photo below:")
        with open(processed_photo_path, "rb") as file:
            st.download_button("Download Processed Photo", file, "processed_photo.jpg")
    else:
        st.write("An error occurred while processing the photo.")



















